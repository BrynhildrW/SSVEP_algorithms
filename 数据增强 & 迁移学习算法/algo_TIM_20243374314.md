# 基于共享冲激响应的跨频率迁移方法
## Cross-stimulus transfer method using common impulse response
***

[论文链接][refer]

Xiong 等人发表在 TNSRE 上的这篇论文，把以往基于叠加模型（Superposition model）的 SSVEP 解码算法，如 Wong 提出的 [tlCCA]、He 等人提出的[跨个体无监督算法]等，进一步拓展到了“multi-stimulus”的概念上。我很好奇这种“simple but useful”的玩意居然不是由 Wong 设计的，毕竟不论是 SSVEP 的冲激响应（Impulse response, IRs），还是集合多个频率共同训练的思路，都是他最早提出的。考虑到 tlCCA 都已经是 2021 年的产物了，不由得感叹“后生可畏”（~~要是我什么时候也能成为这样的后生就好了~~）。

如果读者还记得我们在 tlCCA 专栏中讨论的内容，应该知道 SSVEP 的冲激响应-卷积模型，当然这个名称是偏向算法应用的，它的机制性名称应该是叠加模型，为了表意方便，下文统一简称为“卷积模型”。基于 IRs 设计的分类算法，其原本用意是处理 domain adaptation 问题：使用部分类别训练数据，实现对全类别测试数据的识别。在实操过程中，不同刺激频率的 SSVEP，其 IRs 的初始相位通常一致，但是长度是不一致的，这就导致了一个尴尬的问题：每一类刺激的 IRs 理论上只能由对应类别的数据进行训练，当训练数据样本不足时（如 2 个），eTRCA 尚且表现一般（相对于 eTRCA-R、sc-eTRCA、TDCA 等），更不用说卷积模型了；当训练样本较多时，从实验设计角度考虑，似乎又没必要仅在部分频率上采集那么多试次，摊一摊明明可以采集全类别数据，而且分类性能往往更稳定（见 tlCCA 原文 Fig.7）。这一切的根本矛盾在于，IRs 的长度不一致导致波形信息无法像空间滤波器那样，真正地在各类刺激中共享。也正因此，Wong 的 tlCCA 模板只能实现 $\pm$ 0.2 Hz 内的信息互通。

本专栏介绍的算法通过一个很巧妙的方法解决了这个痛点：已知不同类别 $k$ 对应的周期性脉冲矩阵 $\pmb{H}_k \in \mathbb{R}^{N_{rl,k} \times N_p}$，其主要差异在于 IRs 长度 $N_{rl,k}$，而 SSVEP 单试次响应长度 $N_p$ 是一致的。该算法把 $\pmb{H}_k$ 视为一个二维图像，通过图像放缩技术将各个类别的 $\pmb{H}_k$ 统一对齐至数据集中的最低频率，此时冲激响应最长（$N_{rl,k}$ 最大），图像放缩不容易损失信息，这样各类别的 IRs 长度就一致了。在此基础上，该算法进一步采用“multi-stimulus”思想，把不同频率的数据以及相应的脉冲矩阵分别横向拼接，即可一次性使用多个类别的数据信息获得一个共通模型，即共享冲激响应（Common impulse responses, CIRs）。

![算法流程图](/SSVEP_algorithms/数据增强%20&%20迁移学习算法/20241125.png)

对于已采集 $N_e^{(s)}$ 个类别的源域训练数据 $\pmb{X}_{k^{(s)}}^{i^{(s)}}$，样本类别 $k^{(s)} \in \left\{ k_1, k_2, \cdots, k_{N_e^{(s)}} \right\}$，训练样本数目为 $N_t^{(s)}$（为书写简便起见，假设源域每类数据训练样本数目一致），它们的试次叠加平均模板如下所示，其中 $N_c$、$N_p$ 分别表示导联数与单试次采样点数：
$$
\bar{\pmb{X}}_{k^{(s)}} = \dfrac{1}{N_t^{(s)}} \sum_{i=1}^{N_t^{(s)}} \pmb{X}_{k^{(s)}}^{i^{(s)}} \in \mathbb{R}^{N_c \times N_p}
\tag{1}
$$
假设总体数据集的最低频率为 $f_0$（该类别刺激不一定要在源域数据集中），采样率为 $f_s$，其周期性脉冲矩阵记为 $\pmb{H}_0 \in \mathbb{R}^{N_{rl} \times N_p}$，$N_{rl}=\frac{f_s}{f_0}$。将源域数据对应类别的 $\pmb{H}_{k^{(s)}}$ 通过图像拉伸使其与 $\pmb{H}_0$ 形状一致，拉伸后的脉冲矩阵记为 $\pmb{H}_{k^{(s)}}^{'} \in \mathbb{R}^{N_{rl} \times N_p}$。关于这一操作，原文中使用的是 MATLAB 中的 `imresize()` 函数，在 Python 中，可以使用 OpenCV 库中的 `cv2.resize()` 函数达到同样的效果。需要注意的是，对于源域的不同类别而言，$\pmb{H}_{k^{(s)}}^{'}$ 尽管形状一致，但其在 $N_p$ 对应的维度上包含了不同频率的周期信息，所以是不可混用的。接下来，该算法把源域模板与脉冲矩阵分别按类别横向拼接：
$$
\begin{align}
\notag \tilde{\pmb{X}} &= 
\begin{bmatrix}
    \bar{\pmb{X}}_{k_1} & \bar{\pmb{X}}_{k_2} & \cdots & \bar{\pmb{X}}_{k_{N_e^{(s)}}}
\end{bmatrix} \in \mathbb{R}^{N_c \times \left(N_e^{(s)} N_p \right)}\\
\notag \ \\
\notag \tilde{\pmb{H}} &=
\begin{bmatrix}
    \pmb{H}_{k_1}^{'} & \pmb{H}_{k_2}^{'} & \cdots & \pmb{H}_{k_{N_e^{(s)}}}^{'}
\end{bmatrix} \in \mathbb{R}^{N_{rl} \times \left(N_e^{(s)} N_p \right)}
\end{align}
\tag{2}
$$
之后，按照类似 tlCCA 目标函数的形式，求解 CIRs 成分 $\hat{\pmb{r}} \in \mathbb{R}^{N_k \times N_{rl}}$ 以及相应的空间滤波器 $\hat{\pmb{w}} \in \mathbb{R}^{N_k \times N_c}$：
$$
\hat{\pmb{r}}, \ \ \hat{\pmb{w}} = \underset{\pmb{r}, \pmb{w}}{\arg\min} \left\| \hat{\pmb{r}} \tilde{\pmb{H}} - \hat{\pmb{w}} \tilde{\pmb{X}} \right\|_2^2 = \underset{\pmb{r}, \pmb{w}}{\arg\min} \left\| \hat{\pmb{r}} \sum_{m=1}^{N_e^{(s)}} \pmb{H}_{k_{m}}^{'} - \hat{\pmb{w}} \sum_{m=1}^{N_e^{(s)}} \bar{\pmb{X}}_{k_{m}} \right\|_2^2
\tag{3}
$$
在模板匹配阶段，测试数据是全类别的，且类别信息已知（即刺激频率的类别已知），因此可以提前确定对应的周期脉冲矩阵 $\pmb{H}_k^{'} \in \mathbb{R}^{N_{rl} \times N_p}$。与源域相同地，目标域（全类别）的脉冲矩阵通过图像拉伸与 $\pmb{H}_0$ 对齐。该算法设计了两种判别系数。其中第二个系数，不知道是不是作者笔误，在伪代码部分和流程图部分的表述不一致。此处以流程图为准（看上去似乎更靠谱一些）：
$$
\begin{align}
    \notag \rho_{k,1} &= {\rm corr} \left( \hat{\pmb{w}} \pmb{\mathcal{X}}, \ \ \hat{\pmb{r}} \pmb{H}_k^{'} \right)\\
    \notag \ \\
    \notag \rho_{k,2} &= {\rm CCA} \left( \pmb{\mathcal{X}}, \ \ \pmb{Y}_k \right)
\end{align}, \ \ \ \ \rho_k = \sum_{n=1}^{2} {\rm sign} \left( \rho_{k,n} \right) {\rho_{k,n}}^2
\tag{4}
$$
算法的主要内容基本上到此结束了。结合论文中的 Discussion 部分，有一些观点想与读者分享：

（1）**共享冲激响应与普通冲激响应的关系**：

![CIRs存在性示意图](/SSVEP_algorithms/数据增强%20&%20迁移学习算法/20241125-1.png)

根据原文图 Fig.4 的结果可见，当前受试者的、不同刺激频率的 IRs 在作者经过某种“normalization”操作之后，其叠加平均结果与原始结果具有相当程度的一致性，甚至高过原文图 Fig.2 展示的普通 IRs（假设作者没有使用任何数据疏浚方法）。在计算 CIRs 的时候，我们把周期性脉冲矩阵进行了拉伸以匹配不同的刺激频率。这种图像的拉伸操作在序列上是否可以用超采样（或插值）来替代呢？本文算法相比 tlCCA 有较大幅度的提升，是否说明 CIRs 本身相比 IRs 更加优越呢？

我认为上述问题的答案是否定的。首先从 Benchmark 数据集的角度出发，有三个特点需要指出，一是刺激频率带宽范围相对较小，刺激频率间隔小；二是刺激频带位于低频段，单试次刺激响应强度够高；三是单类别样本数目并不是很多，尽管单试次样本有效时长长达 5 秒，但是一般来说，在调整测试集数据时长的同时应当控制训练集的时长保持一致（听闻某项研究，测试 0.2 秒的数据分类，训练集却用了 2 秒来获取空间滤波器与模板，还掖着藏着不在论文里讲清楚，呵呵）。在这些前提下，使用作者提出算法的训练方法，可以一次性使用成倍数目的训练样本来获取模板与空间滤波器；倘若分别训练之后再把 IRs 通过插值进行长度匹配，则又回到了专栏开始时提出的问题，即训练样本数目可能不足。

对于最近发表的另一个 1-60 Hz 频带范围的[数据集]（下文简称宽带数据集）而言，情况可能会有一些变化。显然，8 Hz SSVEP 的 CIRs 与 25 Hz 的匹配程度会大大弱于与 15 Hz 的匹配程度。一方面，25 Hz 相比 8 Hz 的频率间隔相对较大，可能相应特征的诱发模式已经发生了变化；另一方面，在合适的滤波条件下，8 Hz 与 15 Hz SSVEP 都应该存在二次乃至更高次数的谐波成分，但是 25 Hz 就不好说了，至少二倍频肯定是检测不到。所以 8 Hz 的 IRs 很可能包含了谐波成分（如原文图 Fig.2 中的结果），若是将其套用至相距较远的其它频率，恐怕效果不会太好。此时不论是序列插值还是脉冲矩阵拉伸，都很难说能够避免以上问题，前者的问题当然会更大一些。由此我们将引出下文中的问题（2）。

最后，对于某些特殊的混合范式，如 Han 等人提出的 216 指令集 mVEP-P300-SSVEP 范式，通过合理的编码手段，可以快速获取到具有不同范式特征的大量训练数据。但是 SSVEP 刺激频段发生了一些变化，不同刺激频率 IRs 的波形形态相似性明显下降，或许是受到了其它模态刺激的影响，或许只是受试者个体因素，具体原因不明，说明 CIRs 相比普通 IRs，其优越性并不是全方位的。

总之，普通 IRs 由于其与外部刺激条件的高度绑定，从而具有相当高的稳定性，注意只是稳定性。举个例子，将 tlCCA 用在全类别训练数据场景下，它提取出来的 IRs 一定与原始波形高度吻合，当然这不代表它能干得过 eTRCA 或者 TDCA。由此我们将引出下文中的问题（3）。相比之下，CIRs 很可能不具备这种稳定性，由 CIRs 重建的模板与真实数据的相似性很可能没有普通 IRs 重建模板那么高。

（2）**共享冲激响应的适用范围**：根据（1）中的分析，引出了第二个问题。此处的“适用范围”有两层含义，其一是频带范围，其二是跨个体泛化性。

根据作者在文中所述，该算法的第二判别系数（即 CCA 过程）并没有使用 filter bank 技术。第一判别系数有没有用呢？不清楚。这种含糊其辞的描述不得不让人怀疑，该算法在中高频段是否依然有效。好在本人在宽带数据集上进行了验证，有效，但其效果与频带范围有比较紧密的联系。具体来说，使用相邻 4 个频率的数据作为训练，测试往后 4 个频率的数据，即一个基准频率负责 +8 Hz 带宽范围内的 CIRs 建模。这属于 zero-shot 问题，效果不错；但是使用相邻 8 个频率训练，测试之后 8 个频率时（即带宽范围变成 +16 Hz），效果就大打折扣了。一方面需要分类的类别数目变多了，另一方面说明 CIRs 的适用带宽范围有限，至少 16 Hz 有点太多了。

从原文图 Fig.4 可看出，不同受试者的 CIRs 在形态上存在比较显著的区别。



[refer]: https://ieeexplore.ieee.org/document/10462176/
[tlCCA]: https://ieeexplore.ieee.org/document/9354064
[跨个体无监督算法]: https://ieeexplore.ieee.org/document/10632864/
[数据集]: https://www.nature.com/articles/s41597-024-03023-7